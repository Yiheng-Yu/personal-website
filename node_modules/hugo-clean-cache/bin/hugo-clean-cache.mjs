#!/usr/bin/env node
import fs from "fs";
import fsp from "fs/promises";
import path from "path";
import os from "os";
import pc from "picocolors";

// ---------------------------------------------------------
// Basis & Config laden
// ---------------------------------------------------------

const PROJECT_ROOT = process.cwd();

// Hilfsfunktion: absoluter Pfad
function absPath(p) {
  if (!p) return PROJECT_ROOT;
  return path.isAbsolute(p) ? p : path.join(PROJECT_ROOT, p);
}

const CONFIG_PATH = path.join(PROJECT_ROOT, "hugo-clean-cache.config.json");

let USER_CONFIG = {};
if (fs.existsSync(CONFIG_PATH)) {
  try {
    const raw = await fsp.readFile(CONFIG_PATH, "utf8");
    USER_CONFIG = JSON.parse(raw);
    console.log(
      pc.green("üîß Config geladen:"),
      pc.cyan(path.relative(PROJECT_ROOT, CONFIG_PATH))
    );
  } catch (e) {
    console.log(
      pc.red("‚ùå Fehler beim Lesen von hugo-clean-cache.config.json:"),
      e.message
    );
    process.exit(1);
  }
}

// Default-Konfiguration
const CONFIG = {
  hugoConfig: "hugo.toml",

  cleanResourcesGen: true,
  cleanPublic: true,
  cleanImageCache: true,

  defaultImagesCacheSubdir: "hugogridgallery",

  extraPaths: [],

  ...USER_CONFIG
};

const HUGO_CONFIG = absPath(CONFIG.hugoConfig);

console.log(pc.bold("\nüßπ Starte Cache-Cleanup f√ºr Hugo"));
console.log(`   Projekt:   ${pc.cyan(PROJECT_ROOT)}`);
console.log(`   Hugo-Conf: ${pc.cyan(path.relative(PROJECT_ROOT, HUGO_CONFIG))}\n`);

// ---------------------------------------------------------
// 1) cacheBase bestimmen
// ---------------------------------------------------------

let cacheBase = process.env.HUGO_CACHEDIR || "";

// a) aus hugo.toml lesen (cacheDir = "..."), wenn ENV nicht gesetzt
if (!cacheBase && fs.existsSync(HUGO_CONFIG)) {
  try {
    const toml = await fsp.readFile(HUGO_CONFIG, "utf8");
    const lines = toml.split(/\r?\n/);
    let currentSection = null;

    for (const rawLine of lines) {
      const line = rawLine.trim();

      // Sektionen: [xyz]
      if (line.startsWith("[") && line.endsWith("]")) {
        currentSection = line.slice(1, -1).trim();
        continue;
      }

      // Nur top-level cacheDir (kein Abschnitt)
      if (!currentSection && line.startsWith("cacheDir")) {
        const idx = line.indexOf("=");
        if (idx !== -1) {
          let val = line.slice(idx + 1).trim();
          // Kommentare abschneiden
          const commentIdx = val.indexOf("#");
          if (commentIdx !== -1) {
            val = val.slice(0, commentIdx).trim();
          }
          val = val.replace(/^["']|["']$/g, "").trim();
          if (val) {
            cacheBase = absPath(val);
            console.log(
              pc.green("üîé cacheDir in Hugo-Konfig gefunden:"),
              pc.cyan(val),
              "‚Üí",
              pc.cyan(cacheBase)
            );
            break;
          }
        }
      }
    }
  } catch (e) {
    console.log(
      pc.yellow("‚ö†Ô∏è  Fehler beim Lesen der Hugo-Konfig (cacheDir):"),
      e.message
    );
  }
}

// b) macOS-Default
if (!cacheBase && process.env.HOME) {
  const macCacheRoot = path.join(process.env.HOME, "Library", "Caches");
  if (fs.existsSync(macCacheRoot)) {
    cacheBase = path.join(macCacheRoot, "hugo_cache");
    console.log(
      pc.green("üîé Fallback: macOS Default ‚Üí"),
      pc.cyan(cacheBase)
    );
  }
}

// c) Fallback TMPDIR
if (!cacheBase) {
  const tmpBase = process.env.TMPDIR || os.tmpdir();
  cacheBase = path.join(tmpBase, "hugo_cache");
  console.log(pc.green("üîé Fallback: TMPDIR ‚Üí"), pc.cyan(cacheBase));
}

// ---------------------------------------------------------
// 2) Images-Cache-Unterordner aus hugo.toml bestimmen
// ---------------------------------------------------------

let imagesDirConfig = "";

if (fs.existsSync(HUGO_CONFIG)) {
  try {
    const toml = await fsp.readFile(HUGO_CONFIG, "utf8");
    const lines = toml.split(/\r?\n/);
    let inImages = false;

    for (const rawLine of lines) {
      const line = rawLine.trim();

      if (line.startsWith("[") && line.endsWith("]")) {
        const section = line.slice(1, -1).trim();
        inImages = section === "caches.images";
        continue;
      }

      if (!inImages) continue;
      if (!line || line.startsWith("#")) continue;

      if (line.startsWith("dir")) {
        const idx = line.indexOf("=");
        if (idx !== -1) {
          let val = line.slice(idx + 1).trim();
          const commentIdx = val.indexOf("#");
          if (commentIdx !== -1) {
            val = val.slice(0, commentIdx).trim();
          }
          val = val.replace(/^["']|["']$/g, "").trim();
          if (val) {
            imagesDirConfig = val;
            console.log(
              pc.green("üîé [caches.images].dir gefunden:"),
              pc.cyan(imagesDirConfig)
            );
          }
          break;
        }
      }
    }
  } catch (e) {
    console.log(
      pc.yellow(
        "‚ö†Ô∏è  Fehler beim Lesen der Hugo-Konfig ([caches.images].dir):"
      ),
      e.message
    );
  }
}

let galleryCacheDir = null;

if (CONFIG.cleanImageCache) {
  if (!imagesDirConfig) {
    // Standard: :cacheDir/<defaultImagesCacheSubdir>
    const suffix = CONFIG.defaultImagesCacheSubdir || "hugogridgallery";
    galleryCacheDir = path.join(cacheBase, suffix);
    console.log(
      pc.blue("‚ÑπÔ∏è  Kein spezielles Dir in Config ‚Üí Standard:"),
      pc.cyan(galleryCacheDir)
    );
  } else if (imagesDirConfig.startsWith(":cacheDir")) {
    let suffix = imagesDirConfig.slice(":cacheDir".length);
    suffix = suffix.replace(/^[/\\]+/, ""); // f√ºhrende / entfernen
    galleryCacheDir = path.join(cacheBase, suffix);
    console.log(
      pc.blue("‚ÑπÔ∏è  Pfad mit :cacheDir ersetzt ‚Üí"),
      pc.cyan(galleryCacheDir)
    );
  } else {
    if (path.isAbsolute(imagesDirConfig)) {
      galleryCacheDir = imagesDirConfig;
    } else {
      galleryCacheDir = absPath(imagesDirConfig);
    }
    console.log(
      pc.blue("‚ÑπÔ∏è  Absoluter/relativer Pfad √ºbernommen ‚Üí"),
      pc.cyan(galleryCacheDir)
    );
  }
}

// ---------------------------------------------------------
// 3) Pfade vorbereiten, die gel√∂scht werden sollen
// ---------------------------------------------------------

const targets = [];

const genDir = path.join(PROJECT_ROOT, "resources", "_gen");
const publicDir = path.join(PROJECT_ROOT, "public");

if (CONFIG.cleanResourcesGen) {
  targets.push({ type: "dir", path: genDir, label: "resources/_gen" });
}

if (CONFIG.cleanPublic) {
  // wir l√∂schen nur Inhalt von public/*
  targets.push({ type: "publicChildren", path: publicDir, label: "public/*" });
}

if (CONFIG.cleanImageCache && galleryCacheDir) {
  targets.push({
    type: "dir",
    path: galleryCacheDir,
    label: "[caches.images]"
  });
}

// extraPaths aus der Config
for (const raw of CONFIG.extraPaths || []) {
  if (!raw) continue;
  let resolved;
  if (raw.startsWith(":cacheDir")) {
    let suffix = raw.slice(":cacheDir".length);
    suffix = suffix.replace(/^[/\\]+/, "");
    resolved = path.join(cacheBase, suffix);
  } else {
    resolved = absPath(raw);
  }
  targets.push({ type: "dir", path: resolved, label: raw });
}

// ---------------------------------------------------------
// 4) L√∂schen
// ---------------------------------------------------------

console.log("\n" + pc.bold("üóë  L√∂sche generierte Ressourcen / Caches:"));
for (const t of targets) {
  console.log("   -", pc.cyan(t.path), pc.dim(`(${t.label})`));
}

async function removeDir(target) {
  try {
    await fsp.rm(target, { recursive: true, force: true });
  } catch (e) {
    console.log(pc.yellow(`‚ö†Ô∏è  Fehler beim L√∂schen von ${target}:`), e.message);
  }
}

async function removeChildren(dir) {
  if (!fs.existsSync(dir)) return;
  const entries = await fsp.readdir(dir, { withFileTypes: true });
  await Promise.all(
    entries.map((entry) =>
      fsp.rm(path.join(dir, entry.name), { recursive: true, force: true })
    )
  );
}

for (const t of targets) {
  if (t.type === "dir") {
    await removeDir(t.path);
  } else if (t.type === "publicChildren") {
    await removeChildren(t.path);
  }
}

// ---------------------------------------------------------
// 5) Abschluss
// ---------------------------------------------------------

console.log("\n" + pc.green("‚úÖ Cleanup abgeschlossen."));
console.log("   Projekt-Ressourcen und Caches wurden entfernt.\n");

console.log(pc.bold("üëâ Neu bauen zum Beispiel mit:"));
console.log(
  "   " +
    pc.cyan(
      `HUGO_CACHEDIR="${cacheBase}" hugo --ignoreCache --cleanDestinationDir`
    )
);
console.log();